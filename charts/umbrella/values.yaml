# #############################################################################
# Copyright (c) 2023,2024 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License, Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0
# #############################################################################
---
## TODO: update edc to R23.12 and adjust values
# edcconsumer:
#   nameOverride: edcconsumer
#   install:
#     daps: true
#     postgresql: true
#     vault: true
#   backendService:
#     # TODO: what is the correct value here?
#     httpProxyTokenReceiverUrl: "http://localhost"
#   controlplane:
#     endpoints:
#       management:
#         authKey: consumer-authkey
#     image:
#       repository: *edcCpImage
#       tag: *edcImageTag
#   daps:
#     clientId: *edcConsumerDapsClientId
#     daps:
#       secret:
#         clientId: *dapsClientId
#         clientSecret: *dapsClientSecret
#     image:
#       repository: ghcr.io/fraunhofer-aisec/omejdn-server
#     # podSecurityContext:
#     #   fsGroup: 1000
#     #   runAsNonRoot: true
#     #   runAsUser: 1000
#     #   runAsGroup: 1000
#     # persistence:
#     #   accessMode: "ReadWriteOnce"
#   dataplane:
#     image:
#       repository: *edcDpImage
#       tag: *edcImageTag
#   networkPolicy:
#     enabled: *netPolEnabled
#   participant:
#     id: consumer
#   postgresql:
#     nameOverride: consumer-postgresql
#     networkPolicy:
#       enabled: *netPolEnabled
#       ingressRules:
#         primaryAccessOnlyFrom:
#           enabled: true
#           podSelector:
#             app.kubernetes.io/name: edcconsumer-controlplane
#             app.kubernetes.io/instance: '{{ .Release.Name }}-controlplane'
#     jdbcUrl: "jdbc:postgresql://{{ .Release.Name }}-consumer-postgresql:5432/edc"
#     auth:
#       username: psql-consumer-user
#       password: psql-consumer-password
#   vault:
#     hashicorp:
#       token: *edcVaultToken
#     server:
#       dev:
#         devRootToken: *edcVaultToken
#       networkPolicy:
#         enabled: *netPolEnabled
#     secretNames:
#       dapsPrivateKey: *edcConsumerVaultDapsPrivateKey
#       dapsPublicKey: *edcConsumerVaultDapsPublicKey
#       transferProxyTokenEncryptionAesKey: *edcConsumerVaultTransferEncryptionAesKey
#       transferProxyTokenSignerPrivateKey: *edcConsumerVaultTransferPrivateKey
#       transferProxyTokenSignerPublicKey: *edcConsumerVaultTransferPublicKey

# edcprovider:
#   nameOverride: edcprovider
#   install:
#     daps: false
#     postgresql: true
#     vault: false
#   backendService:
#     # TODO: what is the correct value here?
#     httpProxyTokenReceiverUrl: "http://localhost"
#   controlplane:
#     endpoints:
#       management:
#         authKey: provider-authkey
#     image:
#       repository: *edcCpImage
#       tag: *edcImageTag
#   daps:
#     clientId: *edcProviderDapsClientId
#   dataplane:
#     image:
#       repository: *edcDpImage
#       tag: *edcImageTag
#   participant:
#     id: provider
#     clientId: *edcProviderDapsClientId
#   networkPolicy:
#     enabled: *netPolEnabled
#   postgresql:
#     nameOverride: provider-postgresql
#     jdbcUrl: "jdbc:postgresql://{{ .Release.Name }}-provider-postgresql:5432/edc"
#     auth:
#       username: psql-provider-user
#       password: psql-provider-password
#     networkPolicy:
#       enabled: *netPolEnabled
#       ingressRules:
#         primaryAccessOnlyFrom:
#           enabled: true
#           podSelector:
#             app.kubernetes.io/name: edcprovider-controlplane
#             app.kubernetes.io/instance: '{{ .Release.Name }}-controlplane'
#   vault:
#     hashicorp:
#       token: *edcVaultToken
#     secretNames:
#       dapsPrivateKey: *edcProviderVaultDapsPrivateKey
#       dapsPublicKey: *edcProviderVaultDapsPublicKey
#       transferProxyTokenEncryptionAesKey: *edcProviderVaultTransferEncryptionAesKey
#       transferProxyTokenSignerPrivateKey: *edcProviderVaultTransferPrivateKey
#       transferProxyTokenSignerPublicKey: *edcProviderVaultTransferPublicKey

portal:
  enabled: true
  replicaCount: 1
  postgresql:
    postgresql:
    nameOverride: "portal-backend-postgresql"
    architecture: standalone
  portalAddress: "https://portal.example.org"
  portalBackendAddress: "https://portal-backend.example.org"
  frontend:
    ingress:
      enabled: true
      annotations:
        cert-manager.io/cluster-issuer: "my-ca-issuer"
        nginx.ingress.kubernetes.io/rewrite-target: "/$1"
        nginx.ingress.kubernetes.io/use-regex: "true"
        nginx.ingress.kubernetes.io/enable-cors: "true"
        nginx.ingress.kubernetes.io/cors-allow-origin: "https://*.example.org"
      tls:
        # -- Provide tls secret.
        - secretName: "portal.example.org-tls"
          # -- Provide host for tls secret.
          hosts:
            - "portal.example.org"
      hosts:
        - host: "portal.example.org"
          paths:
            - path: "/(.*)"
              pathType: "ImplementationSpecific"
              backend:
                service: "portal"
                port: 8080
            - path: "/registration/(.*)"
              pathType: "ImplementationSpecific"
              backend:
                service: "registration"
                port: 8080
            - path: "/((assets|documentation)/.*)"
              pathType: "ImplementationSpecific"
              backend:
                service: "assets"
                port: 8080
  backend:
    ingress:
      enabled: true
      name: "portal-backend"
      annotations:
        cert-manager.io/cluster-issuer: "my-ca-issuer"
        nginx.ingress.kubernetes.io/use-regex: "true"
        nginx.ingress.kubernetes.io/enable-cors: "true"
        nginx.ingress.kubernetes.io/proxy-body-size: "8m"
        nginx.ingress.kubernetes.io/cors-allow-origin: "http://localhost:3000, https://*.example.org"
      tls:
        # -- Provide tls secret.
        - secretName: "portal-backend.example.org-tls"
          # -- Provide host for tls secret.
          hosts:
            - "portal-backend.example.org"
      hosts:
        - host: "portal-backend.example.org"
          paths:
            - path: "/api/registration"
              pathType: "Prefix"
              backend:
                service: "registration-service"
                port: 8080
            - path: "/api/administration"
              pathType: "Prefix"
              backend:
                service: "administration-service"
                port: 8080
            - path: "/api/notification"
              pathType: "Prefix"
              backend:
                service: "notification-service"
                port: 8080
            - path: "/api/provisioning"
              pathType: "Prefix"
              backend:
                service: "provisioning-service"
                port: 8080
            - path: "/api/apps"
              pathType: "Prefix"
              backend:
                service: "marketplace-app-service"
                port: 8080
            - path: "/api/services"
              pathType: "Prefix"
              backend:
                service: "services-service"
                port: 8080

centralidp:
  enabled: true
  keycloak:
    nameOverride: "centralidp"
    replicaCount: 1
    initContainers:
      - name: import
        image: docker.io/tractusx/umbrella-init-container:0.0.1-init
        imagePullPolicy: Always
        command:
          - sh
        args:
          - -c
          - |
            echo "Copying realms..."
            cp -R /import/catenax-central/realms/* /realms
        volumeMounts:
        - name: realms
          mountPath: "/realms"
    postgresql:
      nameOverride: "centralidp-postgresql"
      architecture: standalone
    proxy: edge
    extraEnvVars:
      - name: KEYCLOAK_LOG_LEVEL
        value: TRACE
      - name: KEYCLOAK_SPI_TRUSTSTORE_FILE
        value: "/opt/bitnami/keycloak/certs/keycloak.truststore.jks"
      - name: "JAVA_OPTS"
        value: "-Djavax.net.debug=ssl -Djavax.net.ssl.trustStore=$KEYCLOAK_SPI_TRUSTSTORE_PASSWORD -Djavax.net.ssl.trustStorePassword=$KEYCLOAK_SPI_TRUSTSTORE_PASSWORD"
      - name: KEYCLOAK_SPI_TRUSTSTORE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: centralidp-spi
            key: spi-truststore-password
    extraVolumes:
      - name: certificates
        secret:
          secretName: root-secret
          defaultMode: 420
      - name: shared-certs
        emptyDir: {}
      - name: themes
        emptyDir: {}
      - name: realms
        emptyDir: {}
    extraVolumeMounts:
      - name: certificates
        mountPath: /certs
      - name: shared-certs
        mountPath: "/opt/bitnami/keycloak/certs"
      - name: themes
        mountPath: "/opt/bitnami/keycloak/themes/catenax-central"
      - name: realms
        mountPath: "/realms"
    initContainers:
      - name: init-certs
        image: docker.io/bitnami/keycloak:22.0.3-debian-11-r14
        imagePullPolicy: Always
        command: ["/bin/bash"]
        args:
          - -ec
          - |-
            keytool -import -file "/certs/tls.crt" \
                    -keystore "/opt/bitnami/keycloak/certs/keycloak.truststore.jks" \
                    -storepass "${KEYCLOAK_SPI_TRUSTSTORE_PASSWORD}" \
                    -noprompt
        env:
          - name: KEYCLOAK_SPI_TRUSTSTORE_PASSWORD
            valueFrom:
              secretKeyRef:
                name: centralidp-spi
                key: spi-truststore-password
        volumeMounts:
          - name: certificates
            mountPath: /certs
          - name: shared-certs
            mountPath: "/opt/bitnami/keycloak/certs"
    ingress:
      enabled: true
      ingressClassName: "nginx"
      hostname: "centralidp.example.org"
      annotations:
        cert-manager.io/cluster-issuer: "my-ca-issuer"
        nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
        nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS"
        nginx.ingress.kubernetes.io/cors-allow-origin: "https://centralidp.example.org"
        nginx.ingress.kubernetes.io/enable-cors: "true"
        nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
        nginx.ingress.kubernetes.io/proxy-buffering: "on"
        nginx.ingress.kubernetes.io/proxy-buffers-number: "20"
        nginx.ingress.kubernetes.io/use-regex: "true"
      tls: true
  secrets:
    auth:
      existingSecret:
        # -- Password for the admin username 'admin'. Secret-key 'admin-password'.
        adminpassword: ""
      spi:
        truststorePassword: ""

sharedidp:
  enabled: true
  keycloak:
    nameOverride: "sharedidp"
    replicaCount: 1
    initContainers:
      - name: import
        image: docker.io/tractusx/umbrella-init-container:0.0.1-init
        imagePullPolicy: Always
        command:
          - sh
        args:
          - -c
          - |
            echo "Copying realms..."
            cp -R /import/catenax-shared/realms/* /realms
        volumeMounts:
        - name: realms
          mountPath: "/realms"
    postgresql:
      nameOverride: "sharedidp-postgresql"
      architecture: standalone
    proxy: edge
    extraEnvVars:
      - name: KEYCLOAK_SPI_TRUSTSTORE_FILE
        value: "/opt/bitnami/keycloak/certs/keycloak.truststore.jks"
      - name: "JAVA_OPTS"
        value: "-Djavax.net.debug=ssl -Djavax.net.ssl.trustStore=$KEYCLOAK_SPI_TRUSTSTORE_PASSWORD -Djavax.net.ssl.trustStorePassword=$KEYCLOAK_SPI_TRUSTSTORE_PASSWORD"
      - name: KEYCLOAK_SPI_TRUSTSTORE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: sharedidp-spi
            key: spi-truststore-password
    extraVolumes:
      - name: certificates
        secret:
          secretName: root-secret
          defaultMode: 420
      - name: shared-certs
        emptyDir: {}
    extraVolumeMounts:
      - name: certificates
        mountPath: /certs
      - name: shared-certs
        mountPath: "/opt/bitnami/keycloak/certs"
    initContainers:
      - name: init-certs
        image: docker.io/bitnami/keycloak:22.0.3-debian-11-r14
        imagePullPolicy: Always
        command: ["/bin/bash"]
        args:
          - -ec
          - |-
            keytool -import -file "/certs/tls.crt" \
                    -keystore "/opt/bitnami/keycloak/certs/keycloak.truststore.jks" \
                    -storepass "${KEYCLOAK_SPI_TRUSTSTORE_PASSWORD}" \
                    -noprompt
        env:
          - name: KEYCLOAK_SPI_TRUSTSTORE_PASSWORD
            valueFrom:
              secretKeyRef:
                name: sharedidp-spi
                key: spi-truststore-password
        volumeMounts:
          - name: certificates
            mountPath: /certs
          - name: shared-certs
            mountPath: "/opt/bitnami/keycloak/certs"
    ingress:
      enabled: true
      ingressClassName: "nginx"
      hostname: "sharedidp.example.org"
      annotations:
        cert-manager.io/cluster-issuer: "my-ca-issuer"
        nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
        nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS"
        nginx.ingress.kubernetes.io/cors-allow-origin: "https://sharedidp.example.org"
        nginx.ingress.kubernetes.io/enable-cors: "true"
        nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
        nginx.ingress.kubernetes.io/proxy-buffering: "on"
        nginx.ingress.kubernetes.io/proxy-buffers-number: "20"
        nginx.ingress.kubernetes.io/use-regex: "true"
      tls: true
  secrets:
    auth:
      existingSecret:
        # -- Password for the admin username 'admin'. Secret-key 'admin-password'.
        adminpassword: ""
      spi:
        truststorePassword: ""

bpndiscovery:
  enabled: true
  enablePostgres: true
  bpndiscovery:
    authentication: false
    bpndiscoverEndpoint:
      allowedTypes: oen,wmi,passtype,manufacturerPartId
      description: Service to discover BPN for different kind of type numbers
      endpointAddress: /bpndiscovery
      documentation: /bpndiscovery/swagger-ui/index.html
      timeToLive: "31536000"
    livenessProbe:
      initialDelaySeconds: 200
    readinessProbe:
      initialDelaySeconds: 200
  postgresql:
    nameOverride: "bpndiscovery-postgresql"

discoveryfinder:
  enabled: true
  enablePostgres: true
  discoveryfinder:
    authentication: false
    livenessProbe:
      initialDelaySeconds: 200
    readinessProbe:
      initialDelaySeconds: 200
  host: semantics.example.org
  ## If 'authentication' is set to false, no OAuth authentication is enforced
  authentication: false
  properties:
    discoveryfinder:
      # Initial Endpoint for edc discovery with type bpn
      initialEndpoints:
        - type: bpn
          endpointAddress: https://portal-backend.example.org/api/administration/Connectors/discovery
          description: Service to discover connector endpoints based on bpns
          documentation: https://portal-backend.example.org/api/administration/swagger/index.html
  idp:
    issuerUri: "https://centralidp.example.org/auth/realms/CX-Central"
    # publicClientId: ""
  ingress:
    enabled: true
    tls: true
  postgresql:
    nameOverride: "discoveryfinder-postgresql"

sdfactory:
  enabled: true
  secret:
    # -- JWK Set URI
    jwkSetUri: "https://centralidp.example.org/auth/realms/CX-Central/protocol/openid-connect/certs"
    # -- Custodian wallet client id
    clientId: ""
    # -- Custodian wallet client secret
    clientSecret: ""
    # -- Keycloak URL
    authServerUrl: "https://centralidp.example.org/auth"
    # -- Keycloak Realm detail
    realm: ""
    # -- Keycloak Resource detail
    resource: ""
    # -- Details for Custodian wallet URI
    custodianWalletUri: ""
    # -- Details for Clearing House URI
    clearingHouseUri: ""
    # -- Details for Clearing House URL
    clearingHouseServerUrl: ""
    # -- Details for Clearing House Realm
    clearingHouseRealm: ""
    # -- Details for Clearing House Client ID
    clearingHouseClientId: ""
    # -- Details for Clearing House Client Secret
    clearingHouseClientSecret: ""

vault:
  enabled: true
  token: &vault-token root
  url: http://{{ .Release.Name }}-vault:8200
  secrets:
    # TODO add test secret or secret reference. Can this be generated?
    edc-test-miw-keycloak-secret: miw_private_client
    # TODO add certificate or secret reference. Can Key Pairs be generated?
    tokenSignerPublicKey: >-
      -----BEGIN CERTIFICATE-----\n
      test\n
      -----END CERTIFICATE-----
    # TODO add certificate or secret reference. Can Key Pairs be generated?
    tokenSignerPrivateKey: >-
      -----BEGIN PRIVATE KEY-----\n
      test\n
      -----END PRIVATE KEY-----
    # TODO add test secret or secret reference. Can this be generated?
    tokenEncryptionAesKey: test
  injector:
    enabled: false
  server:
    dev:
      enabled: true
      devRootToken: *vault-token
    ingress:
      enabled: false

managed-identity-wallet:
  nameOverride: miw
  fullnameOverride: miw
  enabled: true
  miw:
    authorityWallet:
      bpn: &authority-bpn "BPNL000000000000"
    database:
      host: "{{ .Release.Name }}-miw-postgres"
      secret: "{{ .Release.Name }}-miw-postgres"
    keycloak:
      url: "https://centralidp.example.org"
      clientId: &miw_client miw_private_client  # TODO switch to existing user
  postgresql:
    nameOverride: miw-postgres
    primary:
      persistence:
        enabled: false
        size: 1Gi
  keycloak:
    enabled: false
  livenessProbe:
    initialDelaySeconds: 90
  readinessProbe:
    initialDelaySeconds: 90
